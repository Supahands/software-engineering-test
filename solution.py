import subprocess
from datetime import datetime, timedelta
import unittest

def parse_day_string(day_str):
        """ parse the given string (YYYY-MM-DD) into a datetime object """
        # parse to datetime type
        return datetime.strptime(day_str, "%Y-%m-%d")


def sort_time_stamps(filename='seed.py'):
    """ 
        - Given a list of time stamps that is generated by the provided seed.py
        - Length is defined as the number of days of consecutive logins
        - Output a table with time stamps sorted by consecutive logins, sorted by descending length
    """

    # run the seed.py script
    seed_output = subprocess.run(['python', filename], capture_output=True, text=True)

    # get the captured output
    captured_output = seed_output.stdout

    # clean the output and convert the string to an array
    time_stamp_list = captured_output.strip().strip("[]").replace("'", "").split(", ")

    # sort the time stamps list in ascending order
    time_stamp_list.sort()

    time_stamp_list_len = len(time_stamp_list)

    consecutive_login_list = []
    cl_index = 0
    # traverse the list to find the longest consecutive logins
    for index in range(0, time_stamp_list_len):
        # extract the date w/o the time
        day_string = time_stamp_list[index][:10]

        # previous index day
        prev_day_string = time_stamp_list[index - 1][:10] if index > 0 else day_string
        
        # if empty cl list
        if not consecutive_login_list:
            consecutive_login_list.append({
                'start': day_string,
                'end': day_string,
                'length': 1
            })
            continue

        # if day is same day as previous day, skip
        if day_string == prev_day_string:
            continue

        # if day is the next day from previous day, this is consecutive
        if (parse_day_string(prev_day_string) + timedelta(days=1)) == parse_day_string(day_string):            
            # update the consecutive login end day string
            consecutive_login_list[cl_index]['end'] = day_string
            # increment the length of the consecutive login
            consecutive_login_list[cl_index]['length'] +=1
            continue
        else:
            # if not the next day, then start a new consecutive login object
            cl_index+=1
            consecutive_login_list.append({
                'start': day_string,
                'end': day_string,
                'length': 1
            })

    # sort the list by descending length
    consecutive_login_list = sorted(consecutive_login_list, key=lambda x: x['length'], reverse=True)
    return consecutive_login_list


def table_format(cl_list):
    """ Format the given data into a table format """
    # print the header (Start, End, Length)
    print("+", "=" * 45, "+")
    print("|     START     |      END      |     LENGTH    |")
    print("+", "=" * 45, "+")

    # print the table body
    for cl in cl_list:
        print(f"|   {cl['start']}  |   {cl['end']}  |{'       ' + str(cl['length']) if len(str(cl['length'])) == 1 else '      ' + str(cl['length'])}       |")
        print("+", "-" * 45, "+")    


class TestSum(unittest.TestCase):
    """ Unit test cases """

    @classmethod
    def setUpClass(cls):
        # call my function to get the consecutive logins list
        cls.consecutive_logins = sort_time_stamps()
        print("START TESTS")


    def test_sort_order(self):
        """ test if the sort order is descending by length """
        cl_len = len(self.consecutive_logins)
        for index in range(1, cl_len):
            self.assertLessEqual(self.consecutive_logins[index]['length'], self.consecutive_logins[index - 1]['length'], "This list is not sorted by length in descending order")
        
        print()
        print("TEST CASE #1: PASSED")


    def test_start_less_or_equal_to_end(self):
        """ test if start is always <= end """
        # loop through the list
        for item in self.consecutive_logins:
            self.assertLessEqual(parse_day_string(item['start']), parse_day_string(item['end']))
        
        print()
        print("TEST CASE #2: PASSED")


    def test_start_end_equals_length(self):
        """ test if length equals number of days in start and end """
        # loop through the list
        for item in self.consecutive_logins:
            cs_days = (parse_day_string(item['end']) - parse_day_string(item['start'])).days + 1
            self.assertEqual(cs_days, item['length'], f"START {item['start']} + END {item['end']} is not equal to LENGTH {item['length']}")
        
        print()
        print("TEST CASE #3: PASSED")
    

    def test_length_equals_one(self):
        """ test if length is 1 than start == end """
        for item in self.consecutive_logins:
            if item['start'] == item['end']:
                self.assertEqual(item['length'], 1, f"LENGTH {item['length']} is not correct")
        
        print()
        print("TEST CASE #4: PASSED")
    

    @classmethod
    def tearDownClass(cls):
        print()
        print("TESTS ENDED")
        table_format(cls.consecutive_logins)
    
    
if __name__ == "__main__":
    # run unit test
    unittest.main()